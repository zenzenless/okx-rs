/*
 * REST API
 *
 * # 使用说明   <b>该功能接口用户需先登陆，接口只会请求模拟环境</b><br><br>*Parameters* 面板中点击`Try it out`按钮，编辑请求参数，点击`Execute`按钮发送请求。*Responses* 面板中查看请求结果。<br>
 *
 * The version of the OpenAPI document: v5
 * 
 * Generated by: https://openapi-generator.tech
 */

use base64::encode;
use chrono::Utc;
use hmac::{Hmac, Mac};
use reqwest::{Request, Response};
use sha2::Sha256;
use std::future::Future;
use std::ops::Deref;

#[derive(Debug, Clone)]
pub struct Configuration {
    pub base_path: String,
    pub user_agent: Option<String>,
    pub client:CustomClient, 
    pub basic_auth: Option<BasicAuth>,
    pub oauth_access_token: Option<String>,
    pub bearer_access_token: Option<String>,
    pub api_key: Option<ApiKey>,
}

pub type BasicAuth = (String, Option<String>);

#[derive(Debug, Clone)]
pub struct ApiKey {
    pub prefix: Option<String>,
    pub key: String,
}


impl Configuration {
    pub fn new(base_path:impl Into<String>,api_key:impl Into<String>,secret_key:impl Into<String>,passphrase :impl Into<String>) -> Configuration {
        let mut c=Configuration::default();
        c.client.api_key=api_key.into();
        c.client.secret_key=secret_key.into();
        c.client.passphrase=passphrase.into();
        c.base_path=base_path.into();
        c
    }
}

impl Default for Configuration {
    fn default() -> Self {
        Configuration {
            base_path: "http://localhost".to_owned(),
            user_agent: Some("OpenAPI-Generator/v5/rust".to_owned()),
            client: CustomClient{
                api_key: "".to_owned(),
                secret_key: "".to_owned(),
                passphrase: "".to_owned(),
                client: reqwest::Client::new()
            },
            basic_auth: None,
            oauth_access_token: None,
            bearer_access_token: None,
            api_key: None,
        }
    }
}


#[derive(Debug, Clone)]
pub struct CustomClient {
    api_key: String,
    secret_key: String,
    passphrase: String,
    client: reqwest::Client,
}
impl Deref for CustomClient {
    type Target = reqwest::Client;

    fn deref(&self) -> &Self::Target {
        &self.client
    }
}
impl CustomClient {
    pub fn sign_request<'a>(&self, mut request: reqwest::Request) -> reqwest::Request {
        let timestamp = Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);
        let mut prehash_string = format!(
            "{}{}{}",
            timestamp,
            request.method().as_str(),
            request.url().path()
        );
        let body_string = match request.body() {
            Some(bytes) => String::from_utf8(bytes.as_bytes().unwrap_or("".as_bytes()).to_vec())
                .unwrap_or_default(),
            _ => String::new(),
        };
        if &body_string != "" {
            prehash_string = format!("{}{}", prehash_string, body_string)
        }
        let mut mac = Hmac::<Sha256>::new_from_slice(&self.secret_key.as_bytes())
            .expect("HMAC can take key of any size");
        mac.update(prehash_string.as_bytes());

        let signature = encode(mac.finalize().into_bytes());
        request.headers_mut().insert(
            "OK-ACCESS-SIGN",
            reqwest::header::HeaderValue::from_str(&signature).unwrap(),
        );
        request.headers_mut().insert(
            "OK-ACCESS-TIMESTAMP",
            reqwest::header::HeaderValue::from_str(&timestamp).unwrap(),
        );
        request.headers_mut().insert(
            "OK-ACCESS-PASSPHRASE",
            reqwest::header::HeaderValue::from_str(&self.passphrase).unwrap(),
        );
        request.headers_mut().insert(
            "OK-ACCESS-KEY",
            reqwest::header::HeaderValue::from_str(&self.api_key).unwrap(),
        );
        request.headers_mut().insert(
            "Content-Type",
            reqwest::header::HeaderValue::from_str("application/json").unwrap(),
        );

        request
    }
    pub fn execute(
        &self,
        request: Request,
    ) -> impl Future<Output = Result<Response, reqwest::Error>> {
        let req = self.sign_request(request);
        self.client.execute(req)
    }
}