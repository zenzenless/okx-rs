/*
 * REST API
 *
 * # 使用说明   <b>该功能接口用户需先登陆，接口只会请求模拟环境</b><br><br>*Parameters* 面板中点击`Try it out`按钮，编辑请求参数，点击`Execute`按钮发送请求。*Responses* 面板中查看请求结果。<br>
 *
 * The version of the OpenAPI document: v5
 *
 * Generated by: https://openapi-generator.tech
 */

use base64::encode;
use chrono::Utc;
use hmac::{Hmac, Mac};
use reqwest::{Request, Response};
use sha2::Sha256;
use std::future::Future;
use std::ops::Deref;
#[derive(Debug, Clone)]
pub struct Configuration {
    pub base_path: String,
    pub user_agent: Option<String>,
    pub client: CustomClient,
    pub basic_auth: Option<BasicAuth>,
    pub oauth_access_token: Option<String>,
    pub bearer_access_token: Option<String>,
    pub api_key: Option<ApiKey>,
}

pub type BasicAuth = (String, Option<String>);

#[derive(Debug, Clone)]
pub struct ApiKey {
    pub prefix: Option<String>,
    pub key: String,
}

impl NewConf for Configuration {
   fn new(base_path:impl Into<String>,api_key:impl Into<String>,secret_key:impl Into<String>,passphrase :impl Into<String>)->Self{
        return Configuration{
            base_path:base_path.into(),
            user_agent: Some("OpenAPI-Generator/v5/rust".to_owned()),
            client: CustomClient {
                client: reqwest::Client::new(),
                api_key:api_key.into(),
                secret_key:secret_key.into(),
                passphrase:passphrase.into(),
            },
            basic_auth: None,
            oauth_access_token: None,
            bearer_access_token: None,
            api_key: None,
        }
    }
}

impl Default for Configuration {
    fn default() -> Self {
        Configuration {
            base_path: "http://localhost".to_owned(),
            user_agent: Some("OpenAPI-Generator/v5/rust".to_owned()),
            client: CustomClient {
                client: reqwest::Client::new(),
                api_key: todo!(),
                secret_key: todo!(),
                passphrase: todo!(),
            },
            basic_auth: None,
            oauth_access_token: None,
            bearer_access_token: None,
            api_key: None,
        }
    }
   
}
#[derive(Debug, Clone)]
pub struct CustomClient {
    api_key: String,
    secret_key: String,
    passphrase: String,
    client: reqwest::Client,
}
impl Deref for CustomClient {
    type Target = reqwest::Client;

    fn deref(&self) -> &Self::Target {
        &self.client
    }
}
impl CustomClient {
    pub fn sign_request<'a>(&self, mut request: reqwest::Request) -> reqwest::Request {
        let timestamp = Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);
        let mut prehash_string = format!(
            "{}{}{}",
            timestamp,
            request.method().as_str(),
            request.url().path()
        );
        let body_string = match request.body() {
            Some(bytes) => String::from_utf8(bytes.as_bytes().unwrap_or("".as_bytes()).to_vec())
                .unwrap_or_default(),
            _ => String::new(),
        };
        if &body_string != "" {
            prehash_string = format!("{}{}", prehash_string, body_string)
        }
        let mut mac = Hmac::<Sha256>::new_from_slice(&self.secret_key.as_bytes())
            .expect("HMAC can take key of any size");
        mac.update(prehash_string.as_bytes());

        let signature = encode(mac.finalize().into_bytes());
        request.headers_mut().insert(
            "OK-ACCESS-SIGN",
            reqwest::header::HeaderValue::from_str(&signature).unwrap(),
        );
        request.headers_mut().insert(
            "OK-ACCESS-TIMESTAMP",
            reqwest::header::HeaderValue::from_str(&timestamp).unwrap(),
        );
        request.headers_mut().insert(
            "OK-ACCESS-PASSPHRASE",
            reqwest::header::HeaderValue::from_str(&self.passphrase).unwrap(),
        );
        request.headers_mut().insert(
            "OK-ACCESS-KEY",
            reqwest::header::HeaderValue::from_str(&self.api_key).unwrap(),
        );
        request.headers_mut().insert(
            "Content-Type",
            reqwest::header::HeaderValue::from_str("application/json").unwrap(),
        );

        request
    }
    pub fn execute(
        &self,
        request: Request,
    ) -> impl Future<Output = Result<Response, reqwest::Error>> {
        let req = self.sign_request(request);
        self.client.execute(req)
    }
}


// pub struct AuthInfo {
//     pub api_key: String,
//     pub passphrase: String,
//     pub secret_key: String,
// }

pub trait NewConf {
    fn new(
        base_path: impl Into<String>,
        api_key: impl Into<String>,
        secret_key: impl Into<String>,
        passphrase: impl Into<String>,
    ) -> Self;

    // fn from_auth_info(base_path: impl Into<String>, auth_info: &AuthInfo) -> Self;
}
impl NewConf for CustomClient
where
{
    fn new(
        base_path: impl Into<String>,
        api_key: impl Into<String>,
        secret_key: impl Into<String>,
        passphrase: impl Into<String>,
    ) -> Self {
        unimplemented!()
    }

    // fn from_auth_info(base_path: impl Into<String>, auth_info: &AuthInfo) -> Self {
    //     Self::new(
    //         base_path,
    //         auth_info.api_key.clone(),
    //         auth_info.secret_key.clone(),
    //         auth_info.passphrase.clone(),
    //     )
    // }
}
